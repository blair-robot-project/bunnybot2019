package org.usfirst.frc.team449.robot.sparkMax;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.*;

/**
 * {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}, but as an interface.
 */
public interface IBaseMotorController extends com.ctre.phoenix.motorcontrol.IMotorController {
    /**
     * @return CCI handle for child classes.
     */
    long getHandle();

    /**
     * Returns the Device ID
     *
     * @return Device number.
     */
    @Override
    int getDeviceID();

    /**
     * Sets the appropriate output on the talon, depending on the mode.
     * @param mode The output mode to apply.
     * In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
     * In Current mode, output value is in amperes.
     * In Velocity mode, output value is in position change / 100ms.
     * In Position mode, output value is in encoder ticks or an analog value,
     *   depending on the sensor. 
     * In Follower mode, the output value is the integer device ID of the talon to
     * duplicate.
     *
     * @param outputValue The setpoint value, as described above.
     */
    @Override
    void set(ControlMode mode, double outputValue);

    /**
     * @param mode Sets the appropriate output on the talon, depending on the mode.
     * @param demand0 The output value to apply.
     * 	such as advanced feed forward and/or cascaded close-looping in firmware.
     * In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
     * In Current mode, output value is in amperes.
     * In Velocity mode, output value is in position change / 100ms.
     * In Position mode, output value is in encoder ticks or an analog value,
     *   depending on the sensor. See
     * In Follower mode, the output value is the integer device ID of the talon to
     * duplicate.
     *
     * @param demand1 Supplemental value.  This will also be control mode specific for future features.
     */
    @Override
    void set(ControlMode mode, double demand0, double demand1);

    /**
     * Neutral the motor output by setting control mode to disabled.
     */
    @Override
    void neutralOutput();

    /**
     * Sets the mode of operation during neutral throttle output.
     *
     * @param neutralMode
     *            The desired mode of operation when the Controller output
     *            throttle is neutral (ie brake/coast)
     **/
    @Override
    void setNeutralMode(NeutralMode neutralMode);

    /**
     * Enables a future feature called "Heading Hold".
     * For now this simply updates the CAN signal to the motor controller.
     * Future firmware updates will use this.
     *
     *	@param enable true/false enable
     */
    void enableHeadingHold(boolean enable);

    /**
     * For now this simply updates the CAN signal to the motor controller.
     * Future firmware updates will use this to control advanced cascaded loop behavior.
     *
     *	@param value
     */
    void selectDemandType(boolean value);

    /**
     * Sets the phase of the sensor. Use when controller forward/reverse output
     * doesn't correlate to appropriate forward/reverse reading of sensor.
     * Pick a value so that positive PercentOutput yields a positive change in sensor.
     * After setting this, user can freely call SetInvert() with any value.
     *
     * @param PhaseSensor
     *            Indicates whether to invert the phase of the sensor.
     */
    @Override
    void setSensorPhase(boolean PhaseSensor);

    /**
     * Inverts the hbridge output of the motor controller.
     *
     * This does not impact sensor phase and should not be used to correct sensor polarity.
     *
     * This will invert the hbridge output but NOT the LEDs.
     * This ensures....
     *  - Green LEDs always represents positive request from robot-controller/closed-looping mode.
     *  - Green LEDs correlates to forward limit switch.
     *  - Green LEDs correlates to forward soft limit.
     *
     * @param invert
     *            Invert state to set.
     */
    @Override
    void setInverted(boolean invert);

    /**
     * @return invert setting of motor output.
     */
    @Override
    boolean getInverted();

    /**
     * Configures the open-loop ramp rate of throttle output.
     *
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configOpenloopRamp(double secondsFromNeutralToFull, int timeoutMs);

    /**
     * Configures the closed-loop ramp rate of throttle output.
     *
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configClosedloopRamp(double secondsFromNeutralToFull, int timeoutMs);

    /**
     * Configures the forward peak output percentage.
     *
     * @param percentOut
     *            Desired peak output percentage. [0,1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configPeakOutputForward(double percentOut, int timeoutMs);

    /**
     * Configures the reverse peak output percentage.
     *
     * @param percentOut
     *            Desired peak output percentage.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configPeakOutputReverse(double percentOut, int timeoutMs);

    /**
     * Configures the forward nominal output percentage.
     *
     * @param percentOut
     *            Nominal (minimum) percent output. [0,+1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configNominalOutputForward(double percentOut, int timeoutMs);

    /**
     * Configures the reverse nominal output percentage.
     *
     * @param percentOut
     *            Nominal (minimum) percent output. [-1,0]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configNominalOutputReverse(double percentOut, int timeoutMs);

    /**
     * Configures the output deadband percentage.
     *
     * @param percentDeadband
     *            Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
     *            Pass 0.04 for 4% (factory default).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configNeutralDeadband(double percentDeadband, int timeoutMs);

    /**
     * Configures the Voltage Compensation saturation voltage.
     *
     * @param voltage
     *            This is the max voltage to apply to the hbridge when voltage
     *            compensation is enabled.  For example, if 10 (volts) is specified
     *            and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
     *            then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configVoltageCompSaturation(double voltage, int timeoutMs);

    /**
     * Configures the voltage measurement filter.
     *
     * @param filterWindowSamples
     *            Number of samples in the rolling average of voltage
     *            measurement.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configVoltageMeasurementFilter(int filterWindowSamples, int timeoutMs);

    /**
     * Enables voltage compensation. If enabled, voltage compensation works in
     * all control modes.
     *
     * @param enable
     *            Enable state of voltage compensation.
     **/
    @Override
    void enableVoltageCompensation(boolean enable);

    /**
     * Gets the bus voltage seen by the device.
     *
     * @return The bus voltage value (in volts).
     */
    @Override
    double getBusVoltage();

    /**
     * Gets the output percentage of the motor controller.
     *
     * @return Output of the motor controller (in percent).
     */
    @Override
    double getMotorOutputPercent();

    /**
     * @return applied voltage to motor  in volts.
     */
    @Override
    double getMotorOutputVoltage();

    /**
     * Gets the output current of the motor controller.
     *
     * @return The output current (in amps).
     */
    @Override
    double getOutputCurrent();

    /**
     * Gets the temperature of the motor controller.
     *
     * @return Temperature of the motor controller (in 'C)
     */
    @Override
    double getTemperature();

    /**
     * Select the remote feedback device for the motor controller.
     * Most CTRE CAN motor controllers will support remote sensors over CAN.
     *
     * @param feedbackDevice
     *            Remote Feedback Device to select.
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configSelectedFeedbackSensor(RemoteFeedbackDevice feedbackDevice, int pidIdx, int timeoutMs);

    /**
     * Select the feedback device for the motor controller.
     *
     * @param feedbackDevice
     *            Feedback Device to select.
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode configSelectedFeedbackSensor(FeedbackDevice feedbackDevice, int pidIdx, int timeoutMs);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param deviceID
     *            The CAN ID of the remote sensor device.
     * @param remoteSensorSource
     *            The remote sensor device and signal type to bind.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0
     *            1 for configuring Remote Sensor 1
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configRemoteFeedbackFilter(int deviceID, RemoteSensorSource remoteSensorSource, int remoteOrdinal,
                                         int timeoutMs);

    /**
     * Select what sensor term should be bound to switch feedback device.
     * Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
     * Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
     * The four terms are specified with this routine.  Then Sensor Sum/Difference
     * can be selected for closed-looping.
     *
     * @param sensorTerm Which sensor term to bind to a feedback source.
     * @param feedbackDevice The sensor signal to attach to sensorTerm.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configSensorTerm(SensorTerm sensorTerm, FeedbackDevice feedbackDevice, int timeoutMs);

    /**
     * Get the selected sensor position (in raw sensor units).
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop. See
     *            Phoenix-Documentation for how to interpret.
     *
     * @return Position of selected sensor (in raw sensor units).
     */
    @Override
    int getSelectedSensorPosition(int pidIdx);

    /**
     * Get the selected sensor velocity.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @return selected sensor (in raw sensor units) per 100ms.
     * See Phoenix-Documentation for how to interpret.
     */
    @Override
    int getSelectedSensorVelocity(int pidIdx);

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos
     *            Position to set for the selected sensor (in raw sensor units).
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode setSelectedSensorPosition(int sensorPos, int pidIdx, int timeoutMs);

    /**
     * Sets the period of the given control frame.
     *
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode setControlFramePeriod(ControlFrame frame, int periodMs);

    /**
     * Sets the period of the given status frame.
     *
     * User ensure CAN Bus utilization is not high.
     *
     * This setting is not persistent and is lost when device is reset.
     * If this is a concern, calling application can use HasReset()
     * to determine if the status frame needs to be reconfigured.
     *
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode setControlFramePeriod(int frame, int periodMs);

    /**
     * Sets the period of the given status frame.
     *
     * User ensure CAN Bus utilization is not high.
     *
     * This setting is not persistent and is lost when device is reset. If this
     * is a concern, calling application can use HasReset() to determine if the
     * status frame needs to be reconfigured.
     *
     * @param frameValue
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode setStatusFramePeriod(int frameValue, int periodMs, int timeoutMs);

    /**
     * Sets the period of the given status frame.
     *
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode setStatusFramePeriod(StatusFrame frame, int periodMs, int timeoutMs);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Period of the given status frame.
     */
    int getStatusFramePeriod(int frame, int timeoutMs);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Period of the given status frame.
     */
    @Override
    int getStatusFramePeriod(StatusFrame frame, int timeoutMs);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Period of the given status frame.
     */
    int getStatusFramePeriod(StatusFrameEnhanced frame, int timeoutMs);

    /**
     * Sets the period over which velocity measurements are taken.
     *
     * @param period
     *            Desired period for the velocity measurement. @see
     *            #VelocityMeasPeriod
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode configVelocityMeasurementPeriod(VelocityMeasPeriod period, int timeoutMs);

    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement. Valid values are 1,2,4,8,16,32. If another value
     *            is specified, it will truncate to nearest support value.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode configVelocityMeasurementWindow(int windowSize, int timeoutMs);

    /**
     * Configures the forward limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-F pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the web-based configuration drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configForwardLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                             int deviceID, int timeoutMs);

    /**
     * Configures the reverse limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-R pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the web-based configuration drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configReverseLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                             int deviceID, int timeoutMs);

    /**
     * Configures a limit switch for a local/remote source.
     *
     * For example, a CAN motor controller may need to monitor the Limit-R pin
     * of another Talon, CANifier, or local Gadgeteer feedback connector.
     *
     * If the sensor is remote, a device ID of zero is assumed. If that's not
     * desired, use the four parameter version of this function.
     *
     * @param type
     *            Limit switch source. @see #LimitSwitchSource User can choose
     *            between the feedback connector, remote Talon SRX, CANifier, or
     *            deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the web-based configuration drop down.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode configForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                             int timeoutMs);

    /**
     * Sets the enable state for limit switches.
     *
     * @param enable
     *            Enable state for limit switches.
     **/
    @Override
    void overrideLimitSwitchesEnable(boolean enable);

    /**
     * Configures the forward soft limit threhold.
     *
     * @param forwardSensorLimit
     *            Forward Sensor Position Limit (in raw sensor units).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configForwardSoftLimitThreshold(int forwardSensorLimit, int timeoutMs);

    /**
     * Configures the reverse soft limit threshold.
     *
     * @param reverseSensorLimit
     *            Reverse Sensor Position Limit (in raw sensor units).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configReverseSoftLimitThreshold(int reverseSensorLimit, int timeoutMs);

    /**
     * Configures the forward soft limit enable.
     *
     * @param enable
     *            Forward Sensor Position Limit Enable.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configForwardSoftLimitEnable(boolean enable, int timeoutMs);

    /**
     * Configures the reverse soft limit enable.
     *
     * @param enable
     *            Reverse Sensor Position Limit Enable.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configReverseSoftLimitEnable(boolean enable, int timeoutMs);

    /**
     * Can be used to override-disable the soft limits.
     * This function can be used to quickly disable soft limits without
     * having to modify the persistent configuration.
     *
     * @param enable
     *            Enable state for soft limit switches.
     */
    @Override
    void overrideSoftLimitsEnable(boolean enable);

    /**
     * Sets the 'P' constant in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the P constant.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode config_kP(int slotIdx, double value, int timeoutMs);

    /**
     * Sets the 'I' constant in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the I constant.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode config_kI(int slotIdx, double value, int timeoutMs);

    /**
     * Sets the 'D' constant in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the D constant.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode config_kD(int slotIdx, double value, int timeoutMs);

    /**
     * Sets the 'F' constant in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the F constant.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode config_kF(int slotIdx, double value, int timeoutMs);

    /**
     * Sets the Integral Zone constant in the given parameter slot. If the
     * (absolute) closed-loop error is outside of this zone, integral
     * accumulator is automatically cleared. This ensures than integral wind up
     * events will stop after the sensor gets far enough from its target.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param izone
     *            Value of the Integral Zone constant (closed loop error units X
     *            1ms).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode config_IntegralZone(int slotIdx, int izone, int timeoutMs);

    /**
     * Sets the allowable closed-loop error in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param allowableClosedLoopError
     *            Value of the allowable closed-loop error.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configAllowableClosedloopError(int slotIdx, int allowableClosedLoopError, int timeoutMs);

    /**
     * Sets the maximum integral accumulator in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param iaccum
     *            Value of the maximum integral accumulator (closed loop error
     *            units X 1ms).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configMaxIntegralAccumulator(int slotIdx, double iaccum, int timeoutMs);

    /**
     * Sets the integral accumulator. Typically this is used to clear/zero the
     * integral accumulator, however some use cases may require seeding the
     * accumulator for a faster response.
     *
     * @param iaccum
     *            Value to set for the integral accumulator (closed loop error
     *            units X 1ms).
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode setIntegralAccumulator(double iaccum, int pidIdx, int timeoutMs);

    /**
     * Gets the closed-loop error. The units depend on which control mode is in
     * use. See Phoenix-Documentation information on units.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @return Closed-loop error value.
     */
    @Override
    int getClosedLoopError(int pidIdx);

    /**
     * Gets the iaccum value.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @return Integral accumulator value (Closed-loop error X 1ms).
     */
    @Override
    double getIntegralAccumulator(int pidIdx);

    /**
     * Gets the derivative of the closed-loop error.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @return The error derivative value.
     */
    @Override
    double getErrorDerivative(int pidIdx);

    /**
     * Selects which profile slot to use for closed-loop control.
     *
     * @param slotIdx
     *            Profile slot to select.
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     **/
    @Override
    void selectProfileSlot(int slotIdx, int pidIdx);

    /**
     * Gets the current target of a given closed loop.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @return The closed loop target.
     */
    int getClosedLoopTarget(int pidIdx);

    /**
     * Gets the active trajectory target position using
     * MotionMagic/MotionProfile control modes.
     *
     * @return The Active Trajectory Position in sensor units.
     */
    @Override
    int getActiveTrajectoryPosition();

    /**
     * Gets the active trajectory target velocity using
     * MotionMagic/MotionProfile control modes.
     *
     * @return The Active Trajectory Velocity in sensor units per 100ms.
     */
    @Override
    int getActiveTrajectoryVelocity();

    /**
     * Gets the active trajectory target heading using
     * MotionMagicArc/MotionProfileArc control modes.
     *
     * @return The Active Trajectory Heading in degreees.
     */
    @Override
    double getActiveTrajectoryHeading();

    /**
     * Sets the Motion Magic Cruise Velocity. This is the peak target velocity
     * that the motion magic curve generator can use.
     *
     * @param sensorUnitsPer100ms
     *            Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configMotionCruiseVelocity(int sensorUnitsPer100ms, int timeoutMs);

    /**
     * Sets the Motion Magic Acceleration. This is the target acceleration that
     * the motion magic curve generator can use.
     *
     * @param sensorUnitsPer100msPerSec
     *            Motion Magic Acceleration (in raw sensor units per 100 ms per
     *            second).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configMotionAcceleration(int sensorUnitsPer100msPerSec, int timeoutMs);

    /**
     * Clear the buffered motion profile in both controller's RAM (bottom), and in the
     * API (top).
     */
    @Override
    ErrorCode clearMotionProfileTrajectories();

    /**
     * Retrieve just the buffer count for the api-level (top) buffer. This
     * routine performs no CAN or data structure lookups, so its fast and ideal
     * if caller needs to quickly poll the progress of trajectory points being
     * emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.
     *
     * @return number of trajectory points in the top buffer.
     */
    @Override
    int getMotionProfileTopLevelBufferCount();

    /**
     * Push another trajectory point into the top level buffer (which is emptied
     * into the motor controller's bottom buffer as room allows).
     * @param trajPt to push into buffer.
     * The members should be filled in with these values...
     *
     * 		targPos:  servo position in sensor units.
     *		targVel:  velocity to feed-forward in sensor units
     *                 per 100ms.
     * 		profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
     *						   as the Kv constant for velocity feed-forward. Typically this is hardcoded
     *						   to the a particular slot, but you are free gain schedule if need be.
     *						   Choose from [0,3]
     *		profileSlotSelect1 Which slot to get PIDF gains for cascaded PId.
     *						   This only has impact during MotionProfileArc Control mode.
     *						   Choose from [0,1].
     * 	   isLastPoint  set to nonzero to signal motor controller to keep processing this
     *                     trajectory point, instead of jumping to the next one
     *                     when timeDurMs expires.  Otherwise MP executer will
     *                     eventually see an empty buffer after the last point
     *                     expires, causing it to assert the IsUnderRun flag.
     *                     However this may be desired if calling application
     *                     never wants to terminate the MP.
     *		zeroPos  set to nonzero to signal motor controller to "zero" the selected
     *                 position sensor before executing this trajectory point.
     *                 Typically the first point should have this set only thus
     *                 allowing the remainder of the MP positions to be relative to
     *                 zero.
     *		timeDur Duration to apply this trajectory pt.
     * 				This time unit is ADDED to the exising base time set by
     * 				configMotionProfileTrajectoryPeriod().
     * @return CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
     *         full due to kMotionProfileTopBufferCapacity.
     */
    @Override
    ErrorCode pushMotionProfileTrajectory(TrajectoryPoint trajPt);

    /**
     * Retrieve just the buffer full for the api-level (top) buffer. This
     * routine performs no CAN or data structure lookups, so its fast and ideal
     * if caller needs to quickly poll. Otherwise just use
     * GetMotionProfileStatus.
     *
     * @return number of trajectory points in the top buffer.
     */
    @Override
    boolean isMotionProfileTopLevelBufferFull();

    /**
     * This must be called periodically to funnel the trajectory points from the
     * API's top level buffer to the controller's bottom level buffer. Recommendation
     * is to call this twice as fast as the execution rate of the motion
     * profile. So if MP is running with 20ms trajectory points, try calling
     * this routine every 10ms. All motion profile functions are thread-safe
     * through the use of a mutex, so there is no harm in having the caller
     * utilize threading.
     */
    @Override
    void processMotionProfileBuffer();

    /**
     * Retrieve all status information.
     * For best performance, Caller can snapshot all status information regarding the
     * motion profile executer.
     *
     * @param statusToFill  Caller supplied object to fill.
     *
     * The members are filled, as follows...
     *
     *	topBufferRem:	The available empty slots in the trajectory buffer.
     * 	 				The robot API holds a "top buffer" of trajectory points, so your applicaion
     * 	 				can dump several points at once.  The API will then stream them into the
     * 	 		 		low-level buffer, allowing the motor controller to act on them.
     *
     *	topBufferRem: The number of points in the top trajectory buffer.
     *
     *	btmBufferCnt: The number of points in the low level controller buffer.
     *
     *	hasUnderrun: 	Set if isUnderrun ever gets set.
     * 	 	 	 	 	Only is cleared by clearMotionProfileHasUnderrun() to ensure
     *
     *	isUnderrun:		This is set if controller needs to shift a point from its buffer into
     *					the active trajectory point however
     *					the buffer is empty.
     *					This gets cleared automatically when is resolved.
     *
     *	activePointValid:	True if the active trajectory point has not empty, false otherwise. The members in activePoint are only valid if this signal is set.
     *
     *	isLast:	is set/cleared based on the MP executer's current
     *                trajectory point's IsLast value.  This assumes
     *                IsLast was set when PushMotionProfileTrajectory
     *                was used to insert the currently processed trajectory
     *                point.
     *
     *	profileSlotSelect: The currently processed trajectory point's
     *      			  selected slot.  This can differ in the currently selected slot used
     *       				 for Position and Velocity servo modes
     *
     *	outputEnable:		The current output mode of the motion profile
     *						executer (disabled, enabled, or hold).  When changing the set()
     *						value in MP mode, it's important to check this signal to
     *						confirm the change takes effect before interacting with the top buffer.
     */
    @Override
    ErrorCode getMotionProfileStatus(MotionProfileStatus statusToFill);

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode clearMotionProfileHasUnderrun(int timeoutMs);

    /**
     * Calling application can opt to speed up the handshaking between the robot
     * API and the controller to increase the download rate of the controller's Motion
     * Profile. Ideally the period should be no more than half the period of a
     * trajectory point.
     *
     * @param periodMs
     *            The transmit period in ms.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode changeMotionControlFramePeriod(int periodMs);

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     *
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     * 							This is summed with the trajectory points unique timeDur.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    ErrorCode configMotionProfileTrajectoryPeriod(int baseTrajDurationMs, int timeoutMs);

    /**
     * Gets the last error generated by this object. Not all functions return an
     * error code but can potentially report errors. This function can be used
     * to retrieve those error codes.
     *
     * @return Last Error Code generated by a function.
     */
    @Override
    ErrorCode getLastError();

    /**
     * Polls the various fault flags.
     *
     * @param toFill
     *            Caller's object to fill with latest fault flags.
     * @return Last Error Code generated by a function.
     */
    @Override
    ErrorCode getFaults(Faults toFill);

    /**
     * Polls the various sticky fault flags.
     *
     * @param toFill
     *            Caller's object to fill with latest sticky fault flags.
     * @return Last Error Code generated by a function.
     */
    @Override
    ErrorCode getStickyFaults(StickyFaults toFill);

    /**
     * Clears all sticky faults.
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Last Error Code generated by a function.
     */
    @Override
    ErrorCode clearStickyFaults(int timeoutMs);

    /**
     * Gets the firmware version of the device.
     *
     * @return Firmware version of device. For example: version 1-dot-2 is
     *         0x0102.
     */
    @Override
    int getFirmwareVersion();

    /**
     * Returns true if the device has reset since last call.
     *
     * @return Has a Device Reset Occurred?
     */
    @Override
    boolean hasResetOccurred();

    /**
     * Sets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/limit/target information in
     * the device. Particularly if the device is part of a subsystem that can be
     * replaced.
     *
     * @param newValue
     *            Value for custom parameter.
     * @param paramIndex
     *            Index of custom parameter [0,1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configSetCustomParam(int newValue, int paramIndex, int timeoutMs);

    /**
     * Gets the value of a custom parameter.
     *
     * @param paramIndex
     *            Index of custom parameter [0,1].
     * @param timoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Value of the custom param.
     */
    @Override
    int configGetCustomParam(int paramIndex, int timoutMs);

    /**
     * Sets a parameter. Generally this is not used. This can be utilized in -
     * Using new features without updating API installation. - Errata
     * workarounds to circumvent API implementation. - Allows for rapid testing
     * / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configSetParameter(ParamEnum param, double value, int subValue, int ordinal, int timeoutMs);

    /**
     * Sets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    @Override
    ErrorCode configSetParameter(int param, double value, int subValue, int ordinal, int timeoutMs);

    /**
     * Gets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Value of parameter.
     */
    @Override
    double configGetParameter(ParamEnum param, int ordinal, int timeoutMs);

    /**
     * Gets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Value of parameter.
     */
    @Override
    double configGetParameter(int param, int ordinal, int timeoutMs);

    // ------ Misc. ----------//
    @Override
    int getBaseID();

    /**
     * @return control mode motor controller is in
     */
    ControlMode getControlMode();

    /**
     * Set the control mode and output value so that this motor controller will
     * follow another motor controller. Currently supports following Victor SPX
     * and Talon SRX.
     */
    @Override
    void follow(IMotorController masterToFollow);

    /**
     * When master makes a device, this routine is called to signal the update.
     */
    @Override
    void valueUpdated();

    /**
     * @return object that can get/set individual raw sensor values.
     */
    SensorCollection getSensorCollection();
}
