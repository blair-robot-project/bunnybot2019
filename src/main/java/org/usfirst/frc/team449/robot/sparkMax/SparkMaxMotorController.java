package org.usfirst.frc.team449.robot.sparkMax;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.SetValueMotionProfile;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import com.team254.lib.util.Util;
import org.jetbrains.annotations.NotNull;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Subclass of {@link CANSparkMax} that implements {@link BaseMotorController} functionality.
 */
public class SparkMaxMotorController extends CANSparkMax {
    private static final double VEL_EPSILON = 0.0;
    private static final double POS_EPSILON = 0.0;

    private Instant activePointActivationTime;

    private ControlType controlMode;

    SparkMaxMotorController(final int deviceID, final MotorType type) {
        super(deviceID, type);
    }

    /**
     * @see BaseMotorController#getControlMode()
     */
    public ControlType getControlMode() {
        return this.controlMode;
    }

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos Position to set for the selected sensor (in raw sensor units).
     * @param pidIdx    0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for
     *                  config success and report an error if it times out.
     *                  If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#setSelectedSensorPosition(int, int, int)
     */
    public ErrorCode setSelectedSensorPosition(final int sensorPos, final int pidIdx, final int timeoutMs) {
        // TODO: This method is actually protected, so we might be breaking something by calling it.
        this.setEncPosition(sensorPos);
        return null;
    }

    /**
     * TODO: I think you're correct in that there's no way to retrieve the mode from the controller.
     * Not only sets the value and the control type (analogous to ControlMode), but also updates it in
     * {@link SparkWrapper#motionProfileStatus} because there is no way to retrieve it from the PID controller itself.
     *
     * @param outputValue The value to set, which depends on the control mode:
     *                    * For basic control using duty cycle, this should range between -1 and 1.
     *                    * For voltage control, this is the voltage in volts.
     *                    * For velocity control, this is the angular velocity in RPM.
     *                    * For position control, this is the rotation value.
     *                    * For current control, this is the current in amps.
     * @param mode        The control type to override with.
     * @see BaseMotorController#set(com.ctre.phoenix.motorcontrol.ControlMode, double, double)
     */
    public void set(final ControlType mode, final double outputValue) {
        this.getPIDController().setReference(outputValue, mode);
    }

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     * <p>
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     *
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     *                           This is summed with the trajectory points unique timeDur.
     * @param timeoutMs          Timeout value in ms. If nonzero, function will wait for
     *                           config success and report an error if it times out.
     *                           If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public CANError configMotionProfileTrajectoryPeriod(final int baseTrajDurationMs, final int timeoutMs) {
        return CANError.kNotImplmented;
    }

    public ErrorCode getMotionProfileStatus(@NotNull final MotionProfileStatus statusToFill) {
        this.copyStatusTo(statusToFill);
        return ErrorCode.OK;
    }

    private static class MotionProfileExecutor {
        public static final MotionProfileExecutor INSTANCE = new MotionProfileExecutor();

        private MotionProfileExecutor() {
        }

        public void execute() {
            // TODO: Doesn't seem like the PID controller supports this, so I'm doing this using the encoder.
            //  Might need to rework this in case a quadrature encoder is used.
            //  see if we really need this, the documentation says it just moves stuff into the bottom buffer
            //  make a different async method to process the buffer of points

        }
    }

    public int getMotionProfileTopLevelBufferCount() {
        return this.getBufferCount();
    }

    /**
     * Trajectory points (called the buffer by CTRE)
     */
    public Queue<TrajectoryPoint> trajPoints = new ConcurrentLinkedQueue<>();

    /**
     * Set if {@code isUnderrun} ever gets set. Only is cleared by
     * clearMotionProfileHasUnderrun() to ensure robot logic can react or
     * instrument it.
     *
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    private boolean hasUnderrun;
    /**
     * The current output mode of the motion profile executer (disabled,
     * enabled, or hold). When changing the set() value in MP mode, it's
     * important to check this signal to confirm the change takes effect before
     * interacting with the top buffer.
     */
    public SetValueMotionProfile outputEnable;

    /**
     * The selected PID[0] profile slot of current profile
     */
    public int profileSlotSelect;
    /**
     * The selected auxiliary PID[1] profile slot of current profile
     */
    public int profileSlotSelect1;
    private int bufferCapacity;

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for config
     *                  success and report an error if it times out. If zero, no
     *                  blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    void clearMotionProfileHasUnderrun(final int timeoutMs) {
        this.hasUnderrun = false;
    }

    void clearMotionProfileTrajectories() {
        this.trajPoints.clear();
    }

    ErrorCode pushMotionProfileTrajectory(final TrajectoryPoint pt) {
        // According to Talon' documentation, BaseMotorController returns
        // "CTR_OKAY if trajectory point push ok. ErrorCode if buffer is full due to kMotionProfileTopBufferCapacity."
        if (this.trajPoints.size() >= this.bufferCapacity) return ErrorCode.BufferFull;
        this.trajPoints.add(pt);
        return ErrorCode.OK;
    }

    public int getBufferCount() {
        return this.trajPoints.size();
    }

    /**
     * The available empty slots in the trajectory buffer.
     */
    public int getBufferRem() {
        return this.getBufferCapacity() - this.getBufferCount();
    }

    private int getBufferCapacity() {
        return this.bufferCapacity;
    }

    public boolean hasUnderrun() {
        return this.hasUnderrun;
    }

    /**
     * This is set if Talon/Victor needs to shift a point from its buffer into the
     * active trajectory point however the buffer is empty. This gets cleared
     * automatically when is resolved.
     */
    public boolean isUnderrun() {
        return this.getBufferCount() == 0;
    }

    /**
     * True if the active trajectory point is the last point of the profile.
     */
    public boolean isLast() {
        return !this.trajPoints.isEmpty() && this.trajPoints.peek().isLastPoint;
    }

    public void copyStatusTo(final MotionProfileStatus statusToFill) {
        statusToFill.topBufferRem = this.getBufferRem();
        statusToFill.topBufferCnt = this.getBufferCount();
        statusToFill.btmBufferCnt = 0; // Always zero, since there is no low-level buffer. TODO Should it actually be 1?
        statusToFill.hasUnderrun = this.hasUnderrun();
        statusToFill.isUnderrun = this.isUnderrun();
        statusToFill.activePointValid = this.isActivePointValid();
        statusToFill.isLast = this.isLast();
    }

    /**
     * True if the active trajectory point is not empty, false otherwise. The
     * members in activePoint are only valid if this signal is set.
     */
    public boolean isActivePointValid() {
        return !this.isUnderrun(); // TODO: Dubious that this is how this actually works.
    }

    public TrajectoryPoint activePoint() {
        return this.trajPoints.peek();
    }

    /**
     * The duration in ms of the current trajectory point.
     */
    public int getTimeDurMs() {
        return this.activePoint().timeDur.value;
    }

    /**
     * Moves on to the next point if the active point needs to be consumed.
     */
    public void processMotionProfile() {
        if (this.activePointShouldBeConsumed()) this.consumeActivePoint();
    }

    private TrajectoryPoint consumeActivePoint() {
        final TrajectoryPoint result = this.trajPoints.poll();
        if (this.isActivePointValid()) {
            this.getPIDController().setReference(this.getActivePointRefValue(), this.controlMode);
            this.activePointActivationTime = Instant.now();
        }
        return result;
    }

    private boolean activePointShouldBeConsumed() {
        // We're underrun.
        if (!this.isActivePointValid()) return true;

        // Check if the current point has been running for its target duration.
        if (this.getTimeDurMs() >= Instant.now().until(this.activePointActivationTime, ChronoUnit.MILLIS)) return true;

        // Alternatively, check if the point's reference values have been reached.
        switch (this.controlMode) {
            case kVelocity:
                return Util.epsilonEquals(this.getEncoder().getVelocity(), this.activePoint().velocity, SparkMaxMotorController.VEL_EPSILON);
            case kPosition:
                return Util.epsilonEquals(this.getEncoder().getPosition(), this.activePoint().position, SparkMaxMotorController.POS_EPSILON);
            case kDutyCycle:
            case kVoltage:
            case kSmartMotion:
            case kCurrent:
            case kSmartVelocity:
            default:
                throw new UnsupportedOperationException();
        }
    }

    private double getActivePointRefValue() {
        switch (this.controlMode) {
            case kVelocity:
                return this.activePoint().velocity;
            case kPosition:
                return this.activePoint().position;
            case kDutyCycle:
            case kVoltage:
            case kSmartMotion:
            case kCurrent:
            case kSmartVelocity:
            default:
                throw new UnsupportedOperationException();
        }
    }
}
